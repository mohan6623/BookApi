package com.marvel.springsecurity.vulnerability;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.marvel.springsecurity.model.Users;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Comprehensive OWASP Top 10 vulnerability tests.
 * Tests for SQL injection, XSS, authentication bypass, IDOR, mass assignment,
 * etc.
 */
@SpringBootTest
@AutoConfigureMockMvc
class VulnerabilityTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    // ==================== SQL INJECTION TESTS ====================

    @Nested
    @DisplayName("SQL Injection Tests (A03:2021)")
    class SqlInjectionTests {

        @Test
        @DisplayName("Search endpoint should handle SQL injection in title")
        void testSqlInjectionSearchTitle() throws Exception {
            String[] payloads = {
                    "' OR '1'='1",
                    "'; DROP TABLE books; --",
                    "1' UNION SELECT * FROM users --",
                    "1; INSERT INTO users (email) VALUES ('hacker@evil.com'); --",
                    "' OR 1=1 --",
                    "admin'--"
            };

            for (String payload : payloads) {
                mockMvc.perform(get("/api/books/search")
                        .param("title", payload))
                        .andExpect(result -> {
                            int status = result.getResponse().getStatus();
                            // Should handle gracefully - either return empty results or validation error,
                            // not 500
                            assertTrue(status != 500, "SQL injection payload caused server error: " + payload);
                        });
            }
        }

        @Test
        @DisplayName("Login should handle SQL injection in username")
        void testSqlInjectionLogin() throws Exception {
            String[] maliciousUsernames = {
                    "' OR '1'='1' --",
                    "admin'; DELETE FROM users; --",
                    "' UNION SELECT password FROM users WHERE username='admin' --"
            };

            for (String username : maliciousUsernames) {
                Users user = new Users();
                user.setUsername(username);
                user.setPassword("password");

                mockMvc.perform(post("/api/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(user)))
                        .andExpect(result -> {
                            // Should not return server error (500) or success (200)
                            int status = result.getResponse().getStatus();
                            assertTrue(status != 500, "SQL injection caused server error");
                        });
            }
        }

        @Test
        @DisplayName("Availability check should handle SQL injection")
        void testSqlInjectionAvailability() throws Exception {
            String maliciousUsername = "'; DELETE FROM users; --";

            mockMvc.perform(get("/api/available/username")
                    .param("username", maliciousUsername))
                    .andExpect(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status != 500, "SQL injection caused server error");
                    });
        }
    }

    // ==================== XSS TESTS ====================

    @Nested
    @DisplayName("Cross-Site Scripting Tests (A03:2021)")
    class XssTests {

        @Test
        @DisplayName("Register should handle XSS in username")
        void testXssInUsername() throws Exception {
            String[] xssPayloads = {
                    "<script>alert('XSS')</script>",
                    "<img src=x onerror=alert('XSS')>",
                    "<svg onload=alert('XSS')>",
                    "javascript:alert('XSS')",
                    "<iframe src='javascript:alert(1)'></iframe>",
                    "'\"><script>alert('XSS')</script>"
            };

            for (String payload : xssPayloads) {
                Users user = new Users();
                user.setUsername(payload);
                user.setEmail("test" + System.currentTimeMillis() + "@example.com");
                user.setPassword("Password123!");

                MvcResult result = mockMvc.perform(post("/api/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(user)))
                        .andReturn();

                // Response should not contain unescaped script tags
                String response = result.getResponse().getContentAsString();
                assertFalse(response.contains("<script>") && response.contains("</script>"),
                        "Response contains unescaped script tags");
            }
        }

        @Test
        @DisplayName("Search should handle XSS payloads")
        void testXssInSearch() throws Exception {
            String xssPayload = "<script>document.cookie</script>";

            MvcResult result = mockMvc.perform(get("/api/books/search")
                    .param("title", xssPayload))
                    .andExpect(res -> {
                        int status = res.getResponse().getStatus();
                        // Should handle gracefully - not cause server error
                        assertTrue(status != 500, "XSS payload caused server error");
                    })
                    .andReturn();

            String response = result.getResponse().getContentAsString();
            // Verify XSS is not reflected directly (if response is not empty)
            if (!response.isEmpty()) {
                assertFalse(response.contains("<script>document.cookie</script>"),
                        "XSS payload reflected in response");
            }
        }
    }

    // ==================== AUTHENTICATION BYPASS TESTS ====================

    @Nested
    @DisplayName("Authentication Bypass Tests (A07:2021)")
    class AuthenticationBypassTests {

        @Test
        @DisplayName("Protected endpoints should reject missing auth header")
        void testMissingAuthHeader() throws Exception {
            String[] protectedEndpoints = {
                    "/api/user/profile",
                    "/api/admin/rate-limit-status",
                    "/api/user/update-Username"
            };

            for (String endpoint : protectedEndpoints) {
                mockMvc.perform(get(endpoint))
                        .andExpect(status().isUnauthorized());
            }
        }

        @Test
        @DisplayName("Should reject None algorithm attack")
        void testNoneAlgorithmAttack() throws Exception {
            // JWT with 'none' algorithm - a known attack vector
            String noneAlgoToken = "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0." +
                    "eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJST0xFX0FETUlOIn0.";

            mockMvc.perform(get("/api/admin/rate-limit-status")
                    .header("Authorization", "Bearer " + noneAlgoToken))
                    .andExpect(status().isUnauthorized());
        }

        @Test
        @DisplayName("Should reject token without signature")
        void testTokenWithoutSignature() throws Exception {
            String tokenWithoutSig = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0In0.";

            mockMvc.perform(get("/api/user/profile")
                    .header("Authorization", "Bearer " + tokenWithoutSig))
                    .andExpect(status().isUnauthorized());
        }
    }

    // ==================== IDOR TESTS ====================

    @Nested
    @DisplayName("Insecure Direct Object Reference Tests (A01:2021)")
    class IdorTests {

        @Test
        @DisplayName("Should not expose sensitive data through ID enumeration")
        void testIdEnumeration() throws Exception {
            // Try accessing sequential IDs
            for (int i = 1; i <= 10; i++) {
                mockMvc.perform(get("/api/bookid/" + i))
                        .andExpect(result -> {
                            int status = result.getResponse().getStatus();
                            // Should return 200 (found) or 404 (not found), never 500
                            assertTrue(status == 200 || status == 404,
                                    "Unexpected status: " + status);
                        });
            }
        }

        @Test
        @DisplayName("Negative IDs should be handled gracefully")
        void testNegativeIdHandling() throws Exception {
            mockMvc.perform(get("/api/bookid/-1"))
                    .andExpect(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status != 500, "Negative ID caused server error");
                    });
        }

        @Test
        @DisplayName("Large IDs should be handled gracefully")
        void testLargeIdHandling() throws Exception {
            mockMvc.perform(get("/api/bookid/" + Integer.MAX_VALUE))
                    .andExpect(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status != 500, "Large ID caused server error");
                    });
        }
    }

    // ==================== MASS ASSIGNMENT TESTS ====================

    @Nested
    @DisplayName("Mass Assignment Tests (A01:2021)")
    class MassAssignmentTests {

        @Test
        @DisplayName("Register should not allow role escalation")
        void testRoleEscalationInRegister() throws Exception {
            String maliciousJson = """
                    {
                        "username": "hacker",
                        "email": "hacker@example.com",
                        "password": "Password123!",
                        "role": "ROLE_ADMIN",
                        "emailVerified": true,
                        "roleVersion": 999
                    }
                    """;

            mockMvc.perform(post("/api/register")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(maliciousJson))
                    .andExpect(result -> {
                        int status = result.getResponse().getStatus();
                        // Should succeed but ignore malicious fields
                        assertTrue(status == 201 || status == 200 || status == 400,
                                "Unexpected response for mass assignment attempt");
                    });
        }

        @Test
        @DisplayName("Should not allow userId override")
        void testUserIdOverride() throws Exception {
            String maliciousJson = """
                    {
                        "userId": 1,
                        "username": "hacker",
                        "email": "hacker2@example.com",
                        "password": "Password123!"
                    }
                    """;

            mockMvc.perform(post("/api/register")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(maliciousJson))
                    .andExpect(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status != 500, "userId override caused server error");
                    });
        }
    }

    // ==================== SECURITY HEADERS TESTS ====================

    @Nested
    @DisplayName("Security Headers Tests")
    class SecurityHeadersTests {

        @Test
        @DisplayName("Rate limit headers should be present")
        void testRateLimitHeaders() throws Exception {
            mockMvc.perform(get("/api/available/username")
                    .param("username", "test"))
                    .andExpect(header().exists("X-RateLimit-Limit"))
                    .andExpect(header().exists("X-RateLimit-Remaining"))
                    .andExpect(header().exists("X-RateLimit-Reset"));
        }

        @Test
        @DisplayName("Content-Type should be application/json for API responses")
        void testContentTypeHeader() throws Exception {
            mockMvc.perform(get("/api/books"))
                    .andExpect(content().contentType(MediaType.APPLICATION_JSON));
        }

        @Test
        @DisplayName("Error responses should be JSON format")
        void testErrorResponseFormat() throws Exception {
            mockMvc.perform(get("/api/user/profile"))
                    .andExpect(status().isUnauthorized())
                    .andExpect(content().contentType(MediaType.APPLICATION_JSON));
        }
    }

    // ==================== INPUT VALIDATION TESTS ====================

    @Nested
    @DisplayName("Input Validation Tests")
    class InputValidationTests {

        @Test
        @DisplayName("Should handle very long input strings")
        void testLongInputStrings() throws Exception {
            String longString = "a".repeat(10000);

            mockMvc.perform(get("/api/books/search")
                    .param("title", longString))
                    .andExpect(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status != 500, "Long input caused server error");
                    });
        }

        @Test
        @DisplayName("Should handle special characters")
        void testSpecialCharacters() throws Exception {
            String[] specialChars = { "<>", "\"'", "\\n\\r", "\u0000", "%%", "&&", "||" };

            for (String chars : specialChars) {
                mockMvc.perform(get("/api/books/search")
                        .param("title", chars))
                        .andExpect(result -> {
                            int status = result.getResponse().getStatus();
                            assertTrue(status != 500,
                                    "Special chars '" + chars + "' caused server error");
                        });
            }
        }

        @Test
        @DisplayName("Should handle unicode characters")
        void testUnicodeCharacters() throws Exception {
            String[] unicodeStrings = { "ã“ã‚“ã«ã¡ã¯", "ðŸŽ‰ðŸŽŠ", "ä¸­æ–‡", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "ðŸ’‰" };

            for (String unicode : unicodeStrings) {
                mockMvc.perform(get("/api/books/search")
                        .param("title", unicode))
                        .andExpect(result -> {
                            int status = result.getResponse().getStatus();
                            // Should handle gracefully - either work or reject, not crash
                            assertTrue(status != 500, "Unicode '" + unicode + "' caused server error");
                        });
            }
        }
    }
}
